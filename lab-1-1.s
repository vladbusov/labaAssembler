	PRESERVE8							; 8-битное выравнивание стека
	THUMB								; Режим Thumb (UAL) инструкций

	GET	lab-1-config.s						; include-файлы
	GET	stm32f10x.s

	AREA RESET, CODE, READONLY			; RESET - область при сбросе контроллера, CODE - область кода

	; Таблица векторов прерываний
	DCD STACK_TOP						; Указатель на вершину стека
	DCD Reset_Handler					; Вектор сброса

	ENTRY								; Точка входа в программу

Reset_Handler	PROC					; Вектор сброса
	EXPORT  Reset_Handler				; Делаем Reset_Handler видимым вне этого файла

main									; Основная подпрограмма
	MOV32	R0, PERIPH_BB_BASE + \
			RCC_APB2ENR * 32 + \
			4 * 4						; вычисляем адрес для BitBanding 5-го бита регистра RCC_APB2ENR
	
										; BitAddress = BitBandBase + (RegAddr * 32) + BitNumber * 4
	MOV		R1, #1						; включаем тактирование порта D (в 5-й бит RCC_APB2ENR пишем '1`)
	STR 	R1, [R0]					; загружаем это значение
	
	MOV32	R0, GPIOC_CRH				; адрес порта
	MOV		R1, #0x03					; 4-битная маска настроек для Output mode 50mHz, Push-Pull ("0011")
	LDR		R2, [R0]					; считать порт
    BFI		R2, R1, #0, #4    			; скопировать биты маски в позицию PIN7
	BFI		R2, R1, #4, #4
    STR		R2, [R0]					; загрузить результат в регистр настройки порта
	MOV R9, #0

loop									; Бесконечный цикл
    MOV32	R0, GPIOC_BSRR				; адрес порта выходных сигналов
	MOV R6, #DELAY_T					; Загружаем период T в регистр R6
	
	CMP R9, #1							; Сравниваем регистр с 1
	BEQ case_1							; Переходим к режиму уменьшения
	CMP R9, #0							; Сравниваем регистр с 0
	BEQ case_0							; Переходим к режиму увеличения
	
case_0
loop_2
	CMP R8, #DELAY_VAL_MAX				; Сравниваем R8 с задержкой максимума
	BGE exit_while1						; Если R8 превышает максимум, выходим из цикла
	ADDS R8, #DELAY_SUB					; Вычитаем из R8 зарезирвированное значение
	SUB R7, R6, R8						; R7 = R6 (Период) - R8 (Верхняя задержка)
	
	MOV 	R1, #(PIN9)					; устанавливаем вывод в '1'
	STR 	R1, [R0]					; загружаем в порт
	MOV		R10, R8						; передаем R8 (Верхнюю задержку) как аргумент R10 в функцию delay
	
	BL		delay						; задержка R10
	
	MOV		R1, #(PIN9 << 16)			; сбрасываем в '0'
	STR 	R1, [R0]					; загружаем в порт
	MOV		R10, R7						; передаем R7 (Нижняя задержка) как аргумент R10 в функцию delay
	
	BL		delay						; задержка R10
	
	B loop_2							; Цикл
exit_while1
	MOV R9, #1							; Переключаем режим на уменьшение верхнего порога ШИМ сигнала
	B end_switch						; Начинаем цикл сначала

case_1
loop_3
	CMP R8, #DELAY_VAL_MIN				; Сравниваем R8 с задержкой минимума
	BLT	exit_while2						; Если значение меньше минимума выходим из цикла
	SUBS R8, #DELAY_SUB					; Вычитаем из R8 (задержка верхнего порога ШИМ сигнала) зарезервированное значение
	SUB R7, R6, R8 						; R7 (Нижняя задержка) = R6(Период ШИМ сигнала) - R8 (Верхняя задержка)
	
	MOV 	R1, #(PIN9)					; устанавливаем вывод в '1'
	STR 	R1, [R0]					; загружаем в порт
	MOV		R10, R8						; Передаем аргумент R8 в функцию delay, записывая его в R10
	
	BL		delay						; задержка R10
	
	MOV		R1, #(PIN9 << 16)			; сбрасываем в '0'
	STR 	R1, [R0]					; загружаем в порт
	MOV		R10, R7						; Передаем аргумент R7 в функцию delay, записывая его в R9
	
	BL		delay						; задержка R10
	
	B loop_3
exit_while2
	MOV R9, #0							; переключаем режим на увеличение
	B end_switch						; начинаем цикл сначала
end_switch
	
	B loop								; начинаем цикл сначала
	ENDP
	

delay		PROC					; Подпрограмма задержки
delay_loop
	SUBS	R10, #1						; SUB с установкой флагов результата
	IT 		NE
	BNE		delay_loop					; переход, если Z==0 (результат вычитания не равен нулю)
	BX		LR							; выход из подпрограммы (переход к адресу в регистре LR - вершина стека)
	ENDP
	
	
    END